%TODO expand the introduction? write separate introductions for subsections?
In this chapter, we discuss the syntax and semantics of the simply typed $\lambda$ calculus as can be found in the early literature on the topic (for instance, \cite{friedman1975equality, plotkin:1980}). The reason for this choice is that this presentation seems to give the simplest proof of normalization.

In Section~\ref{sec:stlc-syntax}, we formally define the syntax of the simply typed $\lambda$-calculus. Besides the language of $\lambda$-calculus, we discuss important syntactic notions such as substitution and $\beta\eta$-conversion.

In Section~\ref{sec:stlc-semantics}, we present some basic model theory for the simply typed $\lambda$-calculus. In particular, we prove a soundness theorem and construct the term model.

\section{Syntax} \label{sec:stlc-syntax}

\subsection{Types and terms}

\begin{defn}[Types] \label{def:stlc-types}
We fix some nonempty set $\Basetypes$ of \emph{base types}. The \emph{types} of the simply typed $\lambda$-calculus are generated by the grammar
\[ \sigma, \tau ::= \beta \sep \functy{\sigma}{\tau}, \]
where $\beta$ ranges over $\Basetypes$.
\end{defn}

The type former $\functy{-}{-}$ associates to the right. The set of types is denoted by $\Ty$.

\begin{defn}[Terms] \label{def:stlc-terms}
We fix a pairwise disjoint collection of countable sets $\Var[\sigma]$ indexed by types. Elements of $\Var[\sigma]$ are called \emph{variables of type $\sigma$}. We inductively generate a family of sets $\Tm[\sigma]$ indexed by types $\sigma$ according to the rules in Figure~\ref{fig:stlc-terms}; that is, $(\Tm[\sigma])_{\sigma \in \Ty}$ is the smallest collection of sets closed under the rules. Elements of $\Tm[\sigma]$ are called \emph{terms of type $\sigma$}.
\begin{figure}[h]
\begin{mathpar}
\inferrule[var]
    {x \in \Var[\sigma]}
    {x \in \Tm[\sigma]}
\and
\inferrule[app]
    {t \in \Tm[\functy{\sigma}{\tau}] \and u \in \Tm[\sigma]}
    {\app{t}{u} \in \Tm[\tau]}
\and
\inferrule[lam]
    {x \in \Var[\sigma] \and t \in \Tm[\tau]}
    {\lamv{x}{\sigma}{t} \in \Tm[\functy{\sigma}{\tau}]}
\end{mathpar}
\caption{Terms of the simply typed $\lambda$-calculus}
\label{fig:stlc-terms}
\end{figure}
\end{defn}

The application operator $\app{-}{-}$ associates to the left. We write $\Var = \bigcup_{\sigma \in \Ty}{\Var[\sigma]}$ and $\Tm = \bigcup_{\sigma \in \Ty}{\Tm[\sigma]}$. If $t \in \Var[\sigma]$ (respectively $x \in \Tm[\sigma]$), we also write $\typedtm{t}{\sigma}$ (respectively $\typedvar{x}{\sigma}$) and read it as "$t$ (respectively $x$) has type $\sigma$". We also say that $t$ is an \emph{inhabitant} of $\sigma$, or that $\sigma$ is inhabited by $t$.

The abstraction operator $\lambda$ binds the variable $x$ in the term $\lamv{x}{\sigma}{t}$, similarly how a quantifier binds a variable in a formula. In other words, $\lamv{x}{\sigma}{t}$ introduces the variable $x$ whose scope extends to $t$. The occurrences of $x$ in $t$ are thus called \emph{bound}. Variables that are not bound are called \emph{free}.

\begin{defn} \label{def:free-and-bound-vars}
\begin{enum}
\item The sets of \emph{free variables} $\FV{t}$ and \emph{bound variables} $\BV{t}$ of a term $t$ are defined recursively:
\begin{align*}
\FV{-} &: \Tm \to \finpowset{\Var} &
    \BV{-} &: \Tm \to \finpowset{\Var} \\
\FV{x} &= \singset[x] &
    \BV{x} &= \nul \\
\FV{\app{t}{u}} &= \FV{t} \cup \FV{u} &
    \BV{\app{t}{u}} &= \BV{t} \cup \BV{u} \\
\FV{\lamv{x}{\sigma}{t}} &= \FV{t} \setminus \singset[x] &
    \BV{\lamv{x}{\sigma}{t}} &= \BV{t} \cup \singset[x]
\end{align*}
\item $\FV[\sigma]{t} = \FV{t} \cap \Var[\sigma]$ is the set of free variables of $t$ of type $\sigma$.
\item A term $t$ is \emph{closed} if $\FV{t} = \nul$.
\end{enum}
\end{defn}

Generally in mathematics, the names of bound variables do not matter. The formulas $\forall x. P(x)$ and $\forall y. P(y)$ both denote the statement ``$P$ holds for all individuals''. Similarly, the terms $\lamv{x}{\sigma}{x}$ and $\lamv{y}{\sigma}{y}$ both denote the identity function that returns its input unchanged.

\begin{defn}[$\alpha$-convertibility]
Two terms are \emph{$\alpha$-convertible} if they only differ in the names of bound variables. Details can be found in Chapter 2 of \cite{barendregt:1984}.
\end{defn}

From now on, we identify $\alpha$-convertible terms. This means that we do not distinguish between $\alpha$-convertible terms and treat them as being equal. Formally, this amounts to taking a quotient of terms by the equivalence relation of $\alpha$-convertibility. A consequence of this is that all operations and properties on terms have to be defined on equivalence classes rather than individual terms. In practice, this means that whenever we use a representative of some equivalence class in a definition, we have to prove the invariance of the definition under $\alpha$-convertibility. The details of verifying such assertions are tedious and not too interesting, so we leave them out. See also the discussion in Appendix C of \cite{barendregt:1984}.

\begin{rem} \label{rem:variable-convention}
When working with representatives of $\alpha$-equivalence classes, we employ Barendregt's \emph{variable convention} \cite{barendregt:1984}. This means that all bound variables of all terms that occur in a certain mathematical context (e.g. definition, proof) are assumed to be distinct from all free variables of the terms. Given a countable collection of terms, it is always possible choose representatives in such a way that this condition is satisfied. The convention allows for a simpler treatment of substitution, see Definition~\ref{def:subst-in-term}.
\end{rem}

\begin{rem}
The base types in $\Basetypes$ have no closed inhabitants, so one might wonder why they are necessary. Indeed, the essence of lambda calculus lies in the function types. However, since types are defined inductively, one needs at least one base type as a base case. Otherwise, the set of types would be empty.
\end{rem}

\subsection{Substitution}

The free variables of a term may be viewed as placeholders in which other terms may be substituted. For instance, if $t = \app{x}{y}$ with $\typedvar{x}{\functy{\sigma}{\sigma}}$ and $u = \lamv{z}{\sigma}{z}$, then we can substitute $u$ for $x$ in $t$, denoted by $\subst{t}{\singsubv{x}{u}}$, to obtain $\app{(\lamv{z}{\sigma}{z})}{y}$.

Instead of defining $\subst{t}{\singsubv{x}{u}}$, we take a more general approach where multiple terms may be substituted simultaneously for distinct free variables. This operation is also referred to as \textit{parallel substitution}. We simply call it substitution.

\begin{defn}[Substitution] \label{def:substitution}
A \emph{substitution} is a partial function $\gamma : \Var \pto \Tm$ with finite domain such that if $\typedvar{x}{\sigma}$ and $x \in \dom{\gamma}$, then $\typedtm{\gamma(x)}{\sigma}$.
\end{defn}

The set of substitutions is denoted by $\Sub$.

\begin{notn} \label{not:substitutions}
\hfill \vspace{-3pt}
\begin{items}
\item The notation $\substnf{x}{t}{n}$ stands for the substitution $\gamma$ with
\[ \dom{\gamma} = \{x_1, \ldots, x_n\} \quad\text{and}\quad
    \gamma(x_i) = t_i \quad (i = 1, \ldots, n). \]

\item For a substitution $\gamma$, variable $\typedvar{x}{\sigma}$, and term $\typedtm{t}{\sigma}$, we write $\updsub{\gamma}{x}{t}$ for the \emph{updated substitution} with $\dom{\updsub{\gamma}{x}{t}} = \dom{\gamma} \cup \singset[x]$ and such that
\[
\updsub{\gamma}{x}{t}(y) = \begin{cases}
                              \gamma(y) & \text{if } y \ne x \\
                              t & \text{if } y = x  
                            \end{cases}.
\]

\item For a finite set of variables $\Gamma \subs \Var$, the \emph{identity substitution $\idsub[\Gamma]$ on $\Gamma$} is given by
\[ \idsub[\Gamma](x) = x \quad (x \in \Gamma). \]

\item If $\gamma$ is a substitution, we write
\[ \FV{\gamma} = \bigcup_{x \in \dom{\gamma}}{\FV{\gamma(x)}}. \]
\end{items}
\end{notn}

\begin{defn}[Substitution in terms] \label{def:subst-in-term}
For $\gamma = \substnf{x}{t}{n}$, the expression $\subst{t}{\gamma}$ denotes the result of simultaneously substituting the terms $t_1, \ldots, t_n$ for the free variables $x_1, \ldots, x_n$ of $t$. Formally, it is defined by recursion:
\begin{align*}
\subst{(-)}{(-)} &: \cartprod{\Tm[\sigma]}{\Sub} \to \Tm[\sigma] \\
\subst{x}{\gamma} &= \begin{cases}
                       \gamma(x) & \text{if $x \in \dom{\gamma}$} \\
                       x         & \text{otherwise}
                     \end{cases} \\
\subst{(\app{t}{u})}{\gamma} &= \app{\subst{t}{\gamma}}{\subst{u}{\gamma}} \\
\subst{(\lamv{x}{\sigma}{t})}{\gamma} &= \lamv{x}{\sigma}{\subst{t}{(\updsub{\gamma}{x}{x})}}
\end{align*}
\end{defn}

Note that, by definition, substitution preserves types: if $\typedtm{t}{\sigma}$, then $\typedtm{\subst{t}{\gamma}}{\sigma}$. Furthermore, we have $\FV{\subst{t}{\gamma}} \subs (\FV{t} \setminus \dom{\gamma}) \cup \FV{\gamma}$.

Note also that we use the term \textit{substitution} in two senses. It refers both to the data specifying the terms to be substituted (Definition~\ref{def:substitution}) and to the operation defined in Definition~\ref{def:subst-in-term}.

\begin{rem}
The variable convention (see Remark~\ref{rem:variable-convention}) ensures that we avoid variable capturing, i.e. when a free variable of some $t_i$ becomes bound in the substituted term. Concretely, when writing $\subst{t}{\gamma}$, we assume $\BV{t} \cap \FV{\gamma} = \nul$.
\end{rem}

\subsection{Conversion}

A key feature of the $\lambda$-calculus is the so called $\beta$-rule: applying a function $\lamv{x}{\sigma}{t}$ to an argument $u$ results in substituting $u$ for $x$ in $t$. This is expressed by an equational theory between $\lambda$-terms.

\begin{defn}[$\beta\eta$-conversion]
The typed \emph{conversion relation} is a family of relations indexed by types, generated inductively by the rules in Figure~\ref{fig:stlc-equations}, i.e. it is the least family of relations closed under the rules. We write $\conv{t}{u}{\sigma}$ to mean $(t, u) \in \convrel{\sigma}$.
\begin{figure}[ht]
\begin{mathpar}
\inferrule[refl]{\typedtm{t}{\sigma}}
    {\conv{t}{t}{\sigma}}
\and
\inferrule[trans]
    {\conv{t}{u}{\sigma} \and \conv{u}{v}{\sigma}}
    {\conv{t}{v}{\sigma}}
\and
\inferrule[sym]
    {\conv{t}{u}{\sigma}}
    {\conv{u}{t}{\sigma}}
\\
\inferrule[cong-app]
    {\conv{t}{t'}{\functy{\sigma}{\tau}} \and \conv{u}{u'}{\sigma}}
    {\conv{\app{t}{u}}{\app{t'}{u'}}{\tau}}
\and
\inferrule[cong-lam]
    {\conv{t}{t'}{\tau}}
    {\conv{\lamv{x}{\sigma}{t}}{\lamv{x}{\sigma}{t'}}{\functy{\sigma}{\tau}}}
\\
\inferrule[beta]
    {\typedtm{t}{\tau} \and \typedtm{u}{\sigma}}
    {\conv{\app{(\lamv{x}{\sigma}{t})}{u}}{\subst{t}{\singsubv{x}{u}}}{\tau}}
\and
\inferrule[eta]
    {\typedtm{t}{\functy{\sigma}{\tau}}}
    {\conv{\lamv{x}{\sigma}{\app{t}{x}}}{t}{\functy{\sigma}{\tau}}}
\quad(x \notin \FV{t})
\end{mathpar}
\caption{Rules for equations between $\lambda$-terms}
\label{fig:stlc-equations}
\end{figure}
\end{defn}

Note that by definition, only terms of the same type can be related. This is in contrast with the approach taken in operational semantics where a reduction relation is defined on untyped terms.

The following lemma states that substitution respects conversion.

\begin{lem} \label{lem:sub-conv}
Suppose $\conv{t}{t'}{\sigma}$ and $\gamma, \gamma' \in \Sub$ such that
\[ \dom{\gamma} = \dom{\gamma'} \quad\text{and}\quad
    \conv{\gamma(x)}{\gamma'(x)}{\tau} \quad \text{for all } \typedvar{x}{\tau}. \]
Then $\conv{\subst{t}{\gamma}}{\subst{t'}{\gamma'}}{\sigma}$.
\begin{proof}
%TODO complete this proof?
By induction on the proof of $\conv{t}{t'}{\sigma}$ using the congruence rules \textsc{cong-app} and \textsc{cong-lam}.
\end{proof}
\end{lem}

\subsection{Normal forms}

The rule \textsc{beta} can also be viewed as a reduction rule: $\app{(\lamv{x}{\sigma}{t})}{u}$ \textit{reduces} to $\subst{t}{\singsubv{x}{u}}$. This rule is then called \textit{$\beta$-reduction}. Introducing a directionality is particularly useful for applications to programming: it allows one to run a program by applying reduction steps in sequence. Evaluation of a program is finished when no more reductions are applicable. In this case, the program is said to be in \textit{$\beta$-normal form}.

In the extensional $\lambda$-calculus ($\lambda$-calculus with the rule \textsc{eta}), it is also natural to consider normality with respect to the \textsc{eta} rule. The natural direction for this rule is reducing $\lamv{x}{\sigma}{\app{t}{x}}$ to $t$ (with $x \notin \FV{t}$). Terms in which no more \textsc{beta} or \textsc{eta}-reductions are applicable are said to be in \textit{$\beta\eta$-normal form}.

In a $\beta\eta$-normal form, functions can be partially applied. For instance, if $\typedvar{f}{\functy{\sigma}{\functy{\sigma}{\sigma}}}$ and $\typedvar{x}{\sigma}$ are variables, then $f$ and $\app{f}{x}$ are both in $\beta\eta$-normal form. It is also possible to consider another notion of canonical form, where all functions are fully applied. This is achieved by applying the rule \textsc{eta} in reverse direction, referred to as \textit{$\eta$-expansion}, until all missing arguments are supplied. For instance, $\app{f}{x}$ is converted into $\lamv{y}{\sigma}{\app{\app{f}{x}}{y}}$ (for a fresh variable $y$) in this process. These canonical forms are called \textit{long $\beta\eta$-normal forms}.

To make the distinction between the two notions of normal form more explicit, the former notion is also referred to as \textit{short $\beta\eta$-normal form}. Alternative names for the two notions include \textit{$\eta$-short $\beta$-normal form} and \textit{$\eta$-long $\beta$-normal form}, respectively. The latter terminology emphasizes the fact that $\eta$-long $\beta$-normal forms are normal with respect to $\beta$-reduction but not $\eta$-reduction.

It turns out that long $\beta\eta$-normal forms can be characterized syntactically by a simple set of rules. Since we are only interested in long $\beta\eta$-normal forms, we simply call them normal forms.

\begin{defn}[Neutral terms, normal forms] \label{def:normal-forms}
We define two families of sets of $\lambda$-terms, the sets of \emph{neutral terms} $\Ne[\sigma] \subs \Tm[\sigma]$ and the sets of \emph{normal forms} $\Nf[\sigma] \subs \Tm[\sigma]$. The two families are generated mutually inductively by the clauses in Figure~\ref{fig:stlc-normal-forms}.
\begin{figure}[ht]
\begin{mathpar}
\inferrule[var-ne]
    {x \in \Var[\sigma]}
    {x \in \Ne[\sigma]}
\and
\inferrule[app-ne]
  {m \in \Ne[\functy{\sigma}{\tau}] \and n \in \Nf[\sigma]}
  {\app{m}{n} \in \Ne[\tau]}
\\
\inferrule[shift]
    {m \in \Ne[\beta]}
    {m \in \Nf[\beta]}
\quad (\beta \in \Basetypes)
\and
\inferrule[lam-nf]
    {n \in \Nf[\tau]}
    {\lamv{x}{\sigma}{n} \in \Nf[\functy{\sigma}{\tau}]}
\end{mathpar}
\caption{Normal forms and neutral terms}
\label{fig:stlc-normal-forms}
\end{figure}
\end{defn}

Neutral terms are an auxiliary class of terms used in the definition of normal forms. They are terms with a variable in head position preventing the application of the rule \textsc{beta}.

\begin{defn} \label{def:has-normal-form}
Let $\typedtm{t}{\sigma}$ be a term. We say that \emph{$t$ has a normal form} if there exists an $n \in \Nf[\sigma]$ such that $\conv{t}{n}{\sigma}$. We then also say that \emph{$n$ is a normal form of $t$} or \emph{$t$ has the normal form $n$}.
\end{defn}

\section{Semantics} \label{sec:stlc-semantics}
%TODO make the proofs more readable (e.g. replace stub words such as 'case' by full sentences or phrases)?

\subsection{Applicative structures, models} \label{sec:models}

We first define an appropriate notion of model for the simply typed $\lambda$-calculus.

\begin{defn}[Applicative structure]
An \emph{applicative structure} $\struct{A}$ consists of
\begin{items}
    \item a family of sets $\scomp{\struct{A}}{\sigma}$ indexed by types $\sigma$, and
    \item a family of maps $\sapp[\sigma,\tau][\struct{A}] : \cartprod{\scomp{\struct{A}}{\functy{\sigma}{\tau}}}{\scomp{\struct{A}}{\sigma}} \to \scomp{\struct{A}}{\tau}$ indexed by pairs of types $\sigma, \tau$.
\end{items}
The maps $\sapp[\sigma, \tau]$ are called \emph{application maps}.
\end{defn}

It is worth noting that even though terms of type $\functy{\sigma}{\tau}$ are thought of as functions, $\scomp{\struct{A}}{\functy{\sigma}{\tau}}$ does not necessarily have to be a set of functions. However, every element $f \in \scomp{\struct{A}}{\functy{\sigma}{\tau}}$ of an applicative structure $\struct{A}$ determines a function
\[ \sapp[\sigma,\tau][\struct{A}](f, -) : \scomp{\struct{A}}{\sigma} \to \scomp{\struct{A}}{\tau}, \quad
    x \mapsto \sapp[\sigma,\tau][\struct{A}](f, x). \]
which represents the functional behavior of $f$.

\begin{notn}
We often omit the superscripts and subscripts of the application maps. Furthermore, we often drop the application map completely and write $fx$ for $\sapp[\sigma,\tau](f, x)$ when this does not cause confusion.
\end{notn}

\begin{defn}[Extensional applicative structure] \label{def:ext-app-struct}
We say that an applicative structure $\struct{A}$ is \emph{extensional} if the following holds for all $f, g \in \scomp{\struct{A}}{\functy{\sigma}{\tau}}$:
\[ (\forall x \in \scomp{\struct{A}}{\sigma}. fx = gx) \quad\text{implies}\quad f = g. \]
\end{defn}

\begin{rem} \label{rem:ext-app-struct}
The assignment $f \mapsto \sapp(f, -)$ gives a map $\scomp{\struct{A}}{\functy{\sigma}{\tau}} \to \funcset{\scomp{\struct{A}}{\sigma}}{\scomp{\struct{A}}{\tau}}$. The extensionality axiom is equivalent to the statement that this map is injective. Thus, in an extensional applicative structure, we may identify $\scomp{\struct{A}}{\functy{\sigma}{\tau}}$ with a subset of $\funcset{\scomp{\struct{A}}{\sigma}}{\scomp{\struct{A}}{\tau}}$. Under this identification, the application map $\sapp[\sigma,\tau]$ becomes the evaluation map $(f, x) \mapsto f(x)$.
\end{rem}

To be able to interpret $\lambda$-terms in an applicative structure, one needs to choose meanings for the free variables of the term. This role is filled by environments.

\begin{defn}[Environment] \label{def:environment}
Let $\struct{A}$ be an applicative structure.
\begin{enum}
\item An \emph{environment for $\struct{A}$} is a partial function $\rho : \Var \pto \bigcup_{\sigma \in \Ty}{\scomp{\struct{A}}{\sigma}}$ with finite domain such that if $\typedvar{x}{\sigma}$ and $x \in \dom{\rho}$, then $\rho(x) \in \scomp{\struct{A}}{\sigma}$.

\item If $\Gamma \subs \Var$ is a finite set of variables, then a \emph{$\Gamma$-environment} is an environment $\rho$ such that $\Gamma \subs \dom{\rho}$.
\end{enum}
\end{defn}

The set of environments for $\struct{A}$ is denoted by $\Env[][\struct{A}]$. We write $\Env[\Gamma][\struct{A}]$ for the set of $\Gamma$-environments. As usual, the superscript can be omitted. If $\rho \in \Env[\Gamma]$, we also write $\typedenv{\rho}{\Gamma}$. Clearly, if $\Gamma \subs \Gamma'$ and $\typedenv{\rho}{\Gamma'}$, then $\typedenv{\rho}{\Gamma}$.

Note the formal similarity between substitutions and environments. Environments can be seen as the semantic counterpart to substitutions. Whereas a substitution maps free variables to terms, an environment maps them to elements of a structure. The two notions are connected in the term model (Definition~\ref{def:term-model}), for which environments are essentially the same as substitutions.

\begin{notn} \label{not:environments}
\hfill \vspace{-3pt}
\begin{items}
\item For an environment $\rho$, variable $\typedvar{x}{\sigma}$, and $a \in \scomp{\struct{A}}{\sigma}$, we write $\updenv{\rho}{x}{a}$ for the \emph{updated environment} with $\dom{\updenv{\rho}{x}{a}} = \dom{\rho} \cup \singset[x]$ and such that
\[ \updenv{\rho}{x}{a}(y) = \begin{cases}
                            \rho(y) & \text{if } y \ne x \\
                            a & \text{if } y = x.
                            \end{cases} \]

\item The \emph{empty environment} $\empenv$ is the empty function.
\end{items}
\end{notn}

The updated environment is the semantic analogue of the updated substitution (Notation~\ref{not:substitutions}).

\begin{defn}[Environment model] \label{def:env-model}
An \emph{environment model} $\struct{A}$ is an extensional applicative structure $\struct{A}$ together with an assignment
\[ (t, \rho) \mapsto \sint[\struct{A}]{t}{\rho} \in \scomp{\struct{A}}{\sigma}
    \quad \text{for }\typedtm{t}{\sigma} \text{ and } \typedenv{\rho}{\FV{t}} \]
such that the following equations are satisfied:
\begin{align}
\sint[\struct{A}]{x}{\rho} &= \rho(x) \\
\sint[\struct{A}]{\app{t}{u}}{\rho} &= \sint[\struct{A}]{t}{\rho}\sint[\struct{A}]{u}{\rho} \\
\sint[\struct{A}]{\lamv{x}{\sigma}{t}}{\rho} a &= \sint[\struct{A}]{t}{\updenv{\rho}{x}{a}} \label{eq:int-lam} \quad (a \in \scomp{\struct{A}}{\sigma})
\end{align}
\end{defn}

The value $\sint[\struct{A}]{t}{\rho}$ is called the \emph{interpretation} of $t$ at environment $\rho$ in the model $\struct{A}$. As before, we usually omit the superscript $\struct{A}$.

\begin{rem} \label{rem:env-model-int-uniq}
It follows by a simple induction on terms and the extensionality of $\struct{A}$ that there is at most one possible value for the interpretation $\sint{t}{\rho}$ of $t$. Hence, the conditions in Definition~\ref{def:env-model} can almost be seen as a recursive definition of the interpretation of $\lambda$-terms. The only problem is that the interpretation of $\lamv{x}{\sigma}{t} : \functy{\sigma}{\tau}$ may not be defined if $\scomp{\struct{A}}{\functy{\sigma}{\tau}}$ does not contain enough elements.

More specifically, recall from Remark~\ref{rem:ext-app-struct} that if $\struct{A}$ is an extensional applicative structure, then $\scomp{\struct{A}}{\functy{\sigma}{\tau}}$ may be identified with a subset of $\funcset{\scomp{\struct{A}}{\sigma}}{\scomp{\struct{A}}{\tau}}$. By (\ref{eq:int-lam}), the interpretation $\sint{\lamv{x}{\sigma}{t}}{\rho}$ has to be equal to the function $\scomp{\struct{A}}{\sigma} \to \scomp{\struct{A}}{\tau}$ given by $a \mapsto \sint{t}{\updenv{\rho}{x}{a}}$. However, it is possible that this function is not in $\scomp{\struct{A}}{\functy{\sigma}{\tau}}$.

An environment model is thus an extensional applicative structure in which it is possible to interpret every $\lambda$-term. Hence, we can say that an extensional applicative structure $\struct{A}$ \textit{is} an environment model if the uniquely defined interpretation function is well-defined.
\end{rem}

The intended semantics for the simply typed $\lambda$-calculus is given by sets and functions.

\begin{ex}[Standard model]
Let $X = (X_\beta)_{\beta \in \Basetypes}$ be a family of sets indexed by base types. We define the model $\stdmod{X}$, called the \emph{standard model (over $X$)}, as follows. The sets $\stdmod{X}_\sigma$ are given by recursion on types:
\begin{align*}
\stdmod{X}_\beta &= X_\beta \quad (\beta \in \Basetypes) \\
\stdmod{X}_{\functy{\sigma}{\tau}} &= \funcset{\stdmod{X}_\sigma}{\stdmod{X}_\tau}
\end{align*}
The application map $\sapp[\sigma,\tau][\stdmod{X}] : \cartprod{\funcset{\stdmod{X}_\sigma}{\stdmod{X}_\tau}}{\stdmod{X}_\sigma} \to \stdmod{X}_\tau$ is the evaluation map $(f, x) \mapsto f(x)$. It is clear that this applicative structure is extensional. The interpretation of $\lambda$-terms is defined recursively according to the conditions in Definition~\ref{def:env-model}.
\end{ex}

%TODO make more clear: why does it feel strange from a model-theoretic perspective?
An applicative structure contains an application map to model application of $\lambda$ terms. On the other hand, $\lambda$-abstraction does not have an immediate semantic counterpart, which explains why it is not always possible to interpret a $\lambda$-abstraction. In Definition~\ref{def:env-model}, this was solved by postulating that the intended interpretation function exists. This might feel strange from a model-theoretic perspective: a semantic structure should be adequate to interpret syntax without us having to verify this explicitly. There is an alternative formulation of when an extensional applicative structure is a model of $\lambda$-calculus which meets this criterion.

\begin{defn}[Combinatory model] \label{def:comb-model}
A \emph{combinatory model} $\struct{A}$ is an extensional applicative structure $\struct{A}$  with distinguished elements
\[ K^\struct{A}_{\sigma,\tau} \in \struct{A}_{\functy{\sigma}{\functy{\tau}{\sigma}}}
    \quad\text{and}\quad
    S^\struct{A}_{\sigma,\tau,\chi} \in \struct{A}_{\functy{(\functy{\sigma}{\functy{\tau}{\chi}})}{(\functy{\functy{\sigma}{\tau})}{\functy{\sigma}{\chi}}}} \]
for every $\sigma, \tau, \chi \in \Ty$ such that
\begin{equation} \label{eq:comb-model-KS}
K^\struct{A}_{\sigma,\tau}xy = x \quad\text{and}\quad
    S^\struct{A}_{\sigma,\tau,\chi}fgx = fx(gx)
\end{equation}
for all $x, y, f, g$ of the appropriate types.
\end{defn}

As for the application maps, we may omit the superscripts and subscripts of $K$ and $S$.

\begin{rem}
Combinatory models are so named because they provide semantics for \textit{typed combinatory logic}, a system equivalent to the simply typed $\lambda$-calculus. Combinatory logic bypasses the use of variables by expressing all functions using certain elementary functions called \textit{combinators}. Specifically, it has constants
\[ \typedtm{K_{\sigma,\tau}}{\functy{\sigma}{\functy{\tau}{\sigma}}} \quad\text{and}\quad
    \typedtm{S_{\sigma,\tau,\chi}}{(\functy{\functy{\sigma}{\functy{\tau}{\chi}})}{\functy{(\functy{\sigma}{\tau})}{\functy{\sigma}{\chi}}}} \]
for every $\sigma, \tau, \chi \in \Ty$, satisfying the axioms
\[ \vdash \app{\app{K}{t}}{u} = t \quad\text{and}\quad
    \vdash \app{\app{\app{S}{f}}{g}}{t} = \app{\app{f}{t}}{(\app{g}{t})} \]
for every appropriately typed $t, u, f, g$. It should be clear that the intended semantics of $K_{\sigma,\tau}$ and $S_{\sigma,\tau,\chi}$ in a combinatory model $\struct{A}$ are $K^\struct{A}_{\sigma,\tau}$ and $S^\struct{A}_{\sigma,\tau,\chi}$, respectively.
\end{rem}

\begin{rem} \label{rem:comb-model-KS-uniq}
As in the case for environment models (see Remark~\ref{rem:env-model-int-uniq}), the elements $K$ and $S$ in Definition~\ref{def:comb-model} are uniquely determined by their defining equations (\ref{eq:comb-model-KS}). Thus, every extensional applicative structure $\struct{A}$ can be equipped with at most one choice of $K$ and $S$ to make it a combinatory model. In this case, we may say that $\struct{A}$ \textit{is} a combinatory model.
\end{rem}

\begin{prop} \label{prop:env-comb-mod-equiv}
Suppose $\struct{A}$ is an extensional applicative structure. Then $\struct{A}$ is an environment model if and only if it is a combinatory model.
\begin{proof}
%TODO references for the typed case?
The result follows easily from the syntactic equivalence between simply typed $\lambda$-calculus and typed combinatory logic. For example, given an environment model $\struct{A}$, we can define combinators
\begin{align*}
K_{\sigma,\tau} &= \sint{\lamv{x}{\sigma}{\lamv{y}{\tau}{x}}}{\empenv} \\
S_{\sigma,\tau,\chi} &= \sint{\lamv{f}{\functy{\sigma}{\functy{\tau}{\chi}}}{\lamv{g}{\functy{\sigma}{\tau}}{\lamv{x}{\sigma}{\app{\app{f}{x}}{(\app{g}{x})}}}}}{\empenv}.
\end{align*}
In the other direction, to define $\sint{t}{\rho}$ in a combinatory model, we translate the $\lambda$-closure of $t$ to a combinatory term, take its semantics, and apply the resulting function to the values in the environment $\rho$. Details on the translation to combinators for the untyped case can be found in \cite{barendregt:1984, hindley-seldin:1986}.
\end{proof}
\end{prop}

%TODO confirm this claim
By Proposition~\ref{prop:env-comb-mod-equiv}, we may simply speak of a \textit{model} of $\lambda$-calculus, and use either the environment or the combinatory model formulation to prove that an extensional applicative structure is a model. These kinds of models are also called \emph{Henkin models} in the literature \cite{DBLP:books/el/leeuwen90/Mitchell90}.

\subsection{Basic model theory}
%TODO better title?
We now establish some basic results about Henkin models. The most important are the Soundness Theorem \ref{thm:soundness} and the existence of a term model (Definition~\ref{def:term-model}) which satisfies precisely those equations that are provable in the syntax (Proposition~\ref{prop:term-model-satisfaction}).

\begin{lem} \label{lem:int-different-envs}
Let $\typedtm{t}{\sigma}$. Then for all environments $\typedenv{\rho, \rho'}{\FV{t}}$, we have
\[ (\forall x \in \FV{t}. \rho(x) = \rho'(x)) \quad\text{implies}\quad
    \sint{t}{\rho} = \sint{t}{\rho'}. \]
\begin{proof}
By induction on $t$:
\begin{items}
\item Case $x$:
\[ \sint{x}{\rho} = \rho(x) = \rho'(x) = \sint{x}{\rho'} \]
\item Case $\app{t}{u}$:
\[ \sint{\app{t}{u}}{\rho} = \sint{t}{\rho} \sint{u}{\rho}
    = \sint{t}{\rho'} \sint{u}{\rho'} = \sint{\app{t}{u}}{\rho'} \]
\item Case $\lamv{x}{\sigma}{t}$:
\[ \sint{\lamv{x}{\sigma}{t}}{\rho} a = \sint{t}{\updenv{\rho}{x}{a}}
    = \sint{t}{\updenv{\rho'}{x}{a}} = \sint{\lamv{x}{\sigma}{t}}{\rho'} a \]
In order to apply the induction hypothesis, we have used that $\updenv{\rho}{x}{a}(y) = \updenv{\rho'}{x}{a}(y)$ for all $y \in \FV{t} \cup \singset[x]$. \qedhere
\end{items}
\end{proof}
\end{lem}

\begin{defn}
If $\gamma$ is a substitution and $\rho$ is an environment such that $\typedenv{\rho}{\FV{\gamma}}$, then the environment $\typedenv{\sintsub{\gamma}{\rho}}{\dom{\gamma} \cup \dom{\rho}}$ is defined by
\[ \sintsub{\gamma}{\rho}(x) = \begin{cases}
                               \sint{\gamma(x)}{\rho} & \text{if } x \in \dom{\gamma} \\
                               \rho(x) & \text{if } x \in \dom{\rho} \setminus \dom{\gamma}
                               \end{cases}. \]
\end{defn}

\begin{lem}[Substitution lemma] \label{lem:sub-lemma}
Let $\struct{A}$ be a model. Then for all $\typedtm{t}{\sigma}$, $\gamma \in \Sub$, and $\typedenv{\rho}{(\FV{t} \setminus \dom{\gamma}) \cup \FV{\gamma}}$, we have 
\[ \sint{\subst{t}{\gamma}}{\rho} = \sint{t}{\sintsub{\gamma}{\rho}}. \]
\begin{proof}
By induction on the term $t$:
\begin{items}
\item Case $x$: if $x \in \dom{\gamma}$, then we have
\[ \sint{\subst{x}{\gamma}}{\rho} = \sint{\gamma(x)}{\rho}
    = \sintsub{\gamma}{\rho}(x) = \sint{x}{\sintsub{\gamma}{\rho}}. \]
If $x \notin \dom{\gamma}$, then
\[ \sint{\subst{x}{\gamma}}{\rho} = \sint{x}{\rho} = \rho(x)
    = \sintsub{\gamma}{\rho}(x) = \sint{x}{\sintsub{\gamma}{\rho}}. \]
\item Case $\app{t}{u}$:
\[ \sint{\subst{(\app{t}{u})}{\gamma}}{\rho}
    = \sint{\app{\subst{t}{\gamma}}{\subst{u}{\gamma}}}{\rho}
    = \sint{\subst{t}{\gamma}}{\rho} \sint{\subst{u}{\gamma}}{\rho}
    = \sint{t}{\sint{\gamma}{\rho}} \sint{u}{\sint{\gamma}{\rho}}
    = \sint{\app{t}{u}}{\sint{\gamma}{\rho}} \]

\item Case $\lamv{x}{\sigma}{t}$: Extensionality implies that it suffices to show
\[ \sint{\subst{(\lamv{x}{\sigma}{t})}{\gamma}}{\rho} a
    = \sint{\lamv{x}{\sigma}{t}}{\sintsub{\gamma}{\rho}} a \]
for all $a \in \scomp{\struct{A}}{\sigma}$.
\begin{align*}
\sint{\subst{(\lamv{x}{\sigma}{t})}{\gamma}}{\rho} a
    &= \sint{\lamv{x}{\sigma}{\subst{t}{(\updsub{\gamma}{x}{x})}}}{\rho} a
     = \sint{\subst{t}{(\updsub{\gamma}{x}{x})}}{\updenv{\rho}{x}{a}} \\
    &= \sint{t}{\sint{\updsub{\gamma}{x}{x}}{\updenv{\rho}{x}{a}}}
     = \sint{t}{\updenv{\sint{\gamma}{\rho}}{x}{a}}
     = \sint{\lamv{x}{\sigma}{t}}{\sint{\gamma}{\rho}} a.
\end{align*}
In order to apply the induction hypothesis, we have used that %TODO show this?
\[ \typedenv{\updenv{\rho}{x}{a}}{(\FV{t} \setminus \dom{\updsub{\gamma}{x}{x}}) \cup \FV{\updsub{\gamma}{x}{x}}}. \] 

In the second line, we have used that $\sintsub{\updsub{\gamma}{x}{x}}{\updenv{\rho}{x}{a}} = \updenv{\sintsub{\gamma}{\rho}}{x}{a}$. This is true since
\begin{align*}
\sintsub{\updsub{\gamma}{x}{x}}{\updenv{\rho}{x}{a}}(x)
    &= \sint{\updsub{\gamma}{x}{x}(x)}{\updenv{\rho}{x}{a}}
     = \sint{x}{\updenv{\rho}{x}{a}} \\
    &= \updenv{\rho}{x}{a}(x) = a = \updenv{\sintsub{\gamma}{\rho}}{x}{a}(x),
\end{align*}
\begin{align*}
\sintsub{\updsub{\gamma}{x}{x}}{\updenv{\rho}{x}{a}}(y)
    &= \updenv{\rho}{x}{a}(y) = \rho(y)
     = \sintsub{\gamma}{\rho}(y)
     = \updenv{\sintsub{\gamma}{\rho}}{x}{a}(y)
\end{align*}
if $y \notin \dom{\gamma} \cup \singset[x] = \dom{\updsub{\gamma}{x}{x}}$, and
\begin{align*}
\sintsub{\updsub{\gamma}{x}{x}}{\updenv{\rho}{x}{a}}(y)
    &= \sint{\updsub{\gamma}{x}{x}(y)}{\updenv{\rho}{x}{a}}
     = \sint{\gamma(y)}{\updenv{\rho}{x}{a}} \\
    &= \sint{\gamma(y)}{\rho}
     = \sintsub{\gamma}{\rho}(y)
     = \updenv{\sintsub{\gamma}{\rho}}{x}{a}(y)
\end{align*}
if $y \in \dom{\gamma} \setminus \singset[x]$. In the last case, the equality $\sint{\gamma(y)}{\updenv{\rho}{x}{a}} = \sint{\gamma(y)}{\rho}$ follows from Lemma~\ref{lem:int-different-envs} because $x \notin \FV{\gamma(y)}$. \qedhere
%TODO: make this more readable?
\end{items}
\end{proof}
\end{lem}

\begin{cor} \label{cor:sub-lemma-single-var}
Let $\typedtm{t}{\tau}$, $\typedvar{x}{\sigma}$, and $\typedtm{u}{\sigma}$. Then for all environments $\typedenv{\rho}{(\FV{t} \setminus \singset[x]) \cup \FV{u}}$, we have
\[ \sint{\subst{t}{\singsubv{x}{u}}}{\rho}
    = \sint{t}{\updenv{\rho}{x}{\sint{u}{\rho}}}. \]
\begin{proof}
Follows immediately from Lemma~\ref{lem:sub-lemma} taking $\gamma = \singsubv{x}{u}$, using the equation
\[ \sintsub{\singsubv{x}{u}}{\rho} = \updenv{\rho}{x}{\sint{u}{\rho}}. \]
The latter holds since
\[ \sintsub{\singsubv{x}{u}}{\rho}(x) = \sint{\singsubv{x}{u}(x)}{\rho}
    = \sint{u}{\rho} = \updenv{\rho}{x}{\sint{u}{\rho}}(x) \]
and
\[ \sintsub{\singsubv{x}{u}}{\rho}(y) = \rho(y) = \updenv{\rho}{x}{\sint{u}{\rho}}(y) \]
for $y \in \dom{\rho} \setminus \singset[x]$.
\end{proof}
\end{cor}

\begin{defn}[Satisfaction] \label{def:satisfaction}
Let $\struct{A}$ be a model.
\begin{enum}
\item Suppose $\typedtm{t, u}{\sigma}$, and $\typedenv{\rho}{\FV{t} \cup \FV{u}}$. We say that the equation $\conv{t}{u}{\sigma}$ \emph{holds at $\rho$ in $\struct{A}$}, written as $\modsat{\struct{A}, \rho}{t}{u}{\sigma}$, if $\sint[\struct{A}]{t}{\rho} = \sint[\struct{A}]{u}{\rho}$.

\item The model $\struct{A}$ \emph{satisfies} the equation $\conv{t}{u}{\sigma}$, written as $\modsat{\struct{A}}{t}{u}{\sigma}$, if $\modsat{\struct{A}, \rho}{t}{u}{\sigma}$ for all $\typedenv{\rho}{\FV{t} \cup \FV{u}}$.
\end{enum}
\end{defn}

\begin{thm}[Soundness] \label{thm:soundness}
Let $\struct{A}$ be a model. Then
\[ \conv{t}{u}{\sigma} \quad\text{implies}\quad \modsat{\struct{A}}{t}{u}{\sigma} \]
for all $\typedtm{t, u}{\sigma}$.
\begin{proof}
By induction on the derivation of $\conv{t}{u}{\sigma}$. The cases \textsc{refl}, \textsc{trans}, and \textsc{sym} follow from the fact that $\modsat{\struct{A}}{-}{-}{\sigma}$ is an equivalence relation. For the cases \textsc{cong-app} and \textsc{cong-lam} we use the compositionality of the interpretation of $\lambda$-terms: the meaning of compound terms is defined in terms of the meanings of the subterms. Hence, if the latter are equal at all environments, so are the former.

For \textsc{beta}, we use Corollary~\ref{cor:sub-lemma-single-var}. Let $\typedenv{\rho}{(\FV{t} \setminus \singset[x]) \cup \FV{u}}$. Then
\[ \sint{\app{(\lamv{x}{\sigma}{t})}{u}}{\rho} = \sint{\lamv{x}{\sigma}{t}}{\rho} \sint{u}{\rho} = \sint{t}{\updenv{\rho}{x}{\sint{u}{\rho}}} = \sint{\subst{t}{\singsubv{x}{u}}}{\rho}. \]

Finally, \textsc{eta} follows from the extensionality of $\struct{A}$ and Lemma~\ref{lem:int-different-envs}:
\[ \sint{\lamv{x}{\sigma}{\app{t}{x}}}{\rho} a = \sint{\app{t}{x}}{\updenv{\rho}{x}{a}} = \sint{t}{\updenv{\rho}{x}{a}} \sint{x}{\updenv{\rho}{x}{a}} = \sint{t}{\rho} a. \]
Note that to apply Lemma~\ref{lem:int-different-envs}, we use the assumption that $x \notin \FV{t}$.
\end{proof}
\end{thm}

\begin{defn}[Term model] \label{def:term-model}
The \emph{term model} $\tmmod$ is defined as follows. The set $\tmmod_\sigma$ is the set of terms of type $\sigma$ quotiented by convertibility:
\[ \tmmod_\sigma = \Tm[\sigma] / \convrel{\sigma}. \]
That is, $\tmmod_\sigma = \setof{[t]}{\typedtm{t}{\sigma}}$,
where
\[ [t] = \setof{\typedtm{u}{\sigma}}{\conv{t}{u}{\sigma}} \]
denotes the $\beta\eta$-equivalence class of $t$. The application map is given by
\[ [t] [u] = [\app{t}{u}] \]
for $\typedtm{t}{\functy{\sigma}{\tau}}$ and $\typedtm{u}{\sigma}$.

By definition, an environment for $\tmmod$ is a mapping from variables to equivalences classes of terms. If $\gamma$ is a substitution, then $[\gamma]$ denotes the environment given by $[\gamma](x) = [\gamma(x)]$ for all $x \in \dom{\gamma}$. Every $\rho \in \Env[][\tmmod]$ can be written as $[\gamma]$ for some substitution $\gamma$ by picking representatives in $\rho(x)$ for each $x \in \dom{\rho}$. That said, we define the interpretation into $\tmmod$ as
\[ \sint[\tmmod]{t}{[\gamma]} = [\subst{t}{\gamma}]. \]
\end{defn}

\begin{prop} \label{prop:tm-model}
$\tmmod$ is a well-defined model.
\begin{proof}
To show well-definedness, we need to check that our definitions are independent of the choices of representatives. For the application map, suppose we pick representatives $t', u'$ with $\conv{t}{t'}{\functy{\sigma}{\tau}}$ and $\conv{u}{u'}{\sigma}$. By rule \textsc{cong-app}, we have $\conv{\app{t}{u}}{\app{t'}{u'}}{\tau}$, hence $[\app{t}{u}] = [\app{t'}{u'}]$.

Now suppose $\gamma, \gamma'$ are substitutions such that $[\gamma] = [\gamma']$. Then we have $[\gamma(x)] = [\gamma'(x)]$, hence $\conv{\gamma(x)}{\gamma'(x)}{\sigma}$ for all $\typedvar{x}{\sigma} \in \dom{\gamma}$. By Lemma~\ref{lem:sub-conv}, this implies $\conv{\subst{t}{\gamma}}{\subst{t}{\gamma'}}{\sigma}$, and thus $[\subst{t}{\gamma}] = [\subst{t}{\gamma'}]$. This shows the well-definedness of the interpretation.

To show that the applicative structure $\tmmod$ is extensional, let $[t], [t'] \in \tmmod_{\functy{\sigma}{\tau}}$ and assume that $[t][u] = [t'][u]$ for all $\typedtm{u}{\sigma}$. Let $\typedvar{x}{\sigma}$ be a variable such that $x \notin \FV{t} \cup \FV{u}$. Then we have $[\app{t}{x}] = [t][x] = [t'][x] = [\app{t'}{x}]$ by assumption, hence $\conv{\app{t}{x}}{\app{t'}{x}}{\tau}$. By \textsc{cong-lam}, we derive $\conv{\lamv{x}{\sigma}{\app{t}{x}}}{\lamv{x}{\sigma}{\app{t'}{x}}}{\functy{\sigma}{\tau}}$. Applying \textsc{eta} twice, we get $\conv{t}{t'}{\functy{\sigma}{\tau}}$. Thus, $[t] = [t']$ as desired.

It remains to check that the interpretation satisfies the equations in Definition~\ref{def:env-model}:
\begin{align*}
\sint{x}{[\gamma]} &= [\subst{x}{\gamma}] = [\gamma(x)] = [\gamma](x)
    \quad \text{(note that $x \in \dom{[\gamma]} = \dom{\gamma}$)} \\
\sint{\app{t}{u}}{[\gamma]}
    &= [\subst{(\app{t}{u})}{\gamma}]
     = [\app{\subst{t}{\gamma}}{\subst{u}{\gamma}}]
     = [\subst{t}{\gamma}] [\subst{u}{\gamma}]
     = \sint{t}{[\gamma]} \sint{u}{[\gamma]} \\
\sint{\lamv{x}{\sigma}{t}}{[\gamma]} [u]
    &= [\subst{(\lamv{x}{\sigma}{t})}{\gamma}] [u]
     = [\app{(\lamv{x}{\sigma}{\subst{t}{(\updsub{\gamma}{x}{x})}})}{u}] \\
    &= [\subst{t}{\updsub{(\updsub{\gamma}{x}{x})}{x}{u}}]
     = [\subst{t}{(\updsub{\gamma}{x}{u})}]
     = \sint{t}{[\updsub{\gamma}{x}{u}]}
     = \sint{t}{\updenv{[\gamma]}{x}{[u]}}
\end{align*}
Note that in the last case, $\subst{\subst{t}{(\updsub{\gamma}{x}{x})}}{\singsubv{x}{u}} = \subst{t}{(\updsub{\gamma}{x}{u})}$ only because $x \notin \FV{\gamma}$.
\end{proof}
\end{prop}

%TODO can we call this completeness?
\begin{thm} \label{prop:term-model-satisfaction}
For all $t$ and $u$, $\conv{t}{u}{\sigma}$ if and only if $\modsat{\tmmod}{t}{u}{\sigma}$. 
\begin{proof}
The only if part is a corollary of Theorem~\ref{thm:soundness} and Proposition~\ref{prop:tm-model}. If $\modsat{\tmmod}{t}{u}{\sigma}$, then $\sint[\tmmod]{t}{[\idsub]} = \sint[\tmmod]{u}{[\idsub]}$, where $\idsub$ is the identity substitution on $\FV{t}$. Then
\[ [t] = [\subst{t}{(\idsub)}] = \sint{t}{[\idsub]} = \sint{u}{[\idsub]}
    = [\subst{u}{(\idsub)}] = [u], \]
and hence $\conv{t}{u}{\sigma}$.
\end{proof}
\end{thm}

\begin{comment}
NOTE: product structure is only a model of all the components of the two factors are nonempty.

\begin{def}[Product of models]
Let $\struct{A}$ and $\struct{B}$ be models. The \emph{product model} $\cprod{\struct{A}}{\struct{B}}$ is defined as follows:
\begin{items}
\item $(\cprod{\struct{A}}{\struct{B}})_\sigma = \cartprod{\scomp{\struct{A}}{\sigma}}{\scomp{\struct{B}}{\sigma}}$;
\item $\sapp[\sigma,\tau][\cprod{\struct{A}}{\struct{B}}]((f, g), (x, y))
        = (\sapp[\sigma,\tau][\struct{A}](f, x), \sapp[\sigma,\tau][\struct{B}](g, y))$;
\item $\sint[\cprod{\struct{A}}{\struct{B}}]{t}{\rho}
        = (\sint[\struct{A}]{t}{\rho}, \sint[\struct{B}]{t}{\rho})$.
\end{items}
\end{def}

\begin{prop}
If $\scomp{\struct{A}}{\sigma}$ and $\scomp{\struct{B}}{\sigma}$ are nonempty for all $\sigma \in \Ty$, then $\cprod{\struct{A}}{\struct{B}}$ is a model.
\begin{proof}
Extensionality: if $(f, g)(x, y) = (f', g')(x, y)$ for all $x, y$, then $(fx, gy) = (f'x, g'y)$ for all $x, y$, i.e. $fx = f'x$ and $gy = g'y$ for all
\end{proof}
\end{prop}
\end{comment}

\subsection{Homomorphisms}

When studying the properties of a class of mathematical structures, it is worthwhile to consider structure-preserving mappings between the structures. These mappings are usually called \textit{homomorphisms}. For example, functions between groups preserving the group operation are called \textit{group homomorphisms} and they are an essential concept in group theory.

We can apply the same idea to the notions of model defined in Section~\ref{sec:models}. Although we do not make use of homomorphisms between Henkin models in this thesis, we believe it is worth mentioning them to make it easier to relate this theory to the categorical semantics to be introduced in Chapter~\ref{chap:stlc-cat}.

\begin{defn}[Homomorphism of applicative structures]
Let $\struct{A}$ and $\struct{B}$ be applicative structures. A \emph{homomorphism of applicative structures} $h : \struct{A} \to \struct{B}$ is a family of maps $(h_\sigma : \scomp{\struct{A}}{\sigma} \to \scomp{\struct{B}}{\sigma})_{\sigma \in \Ty}$ such that
\[ h_\tau(\sapp[\sigma,\tau][\struct{A}](f, x)) =
    \sapp[\sigma,\tau][\struct{B}](h_{\functy{\sigma}{\tau}}(f), h_\sigma(x)) \]
for all $\sigma, \tau \in \Ty$, $f \in \scomp{\struct{A}}{\functy{\sigma}{\tau}}$, and $x \in \scomp{\struct{A}}{\sigma}$.
\end{defn}

\begin{notn}
Let $h : \struct{A} \to \struct{B}$ be a homomorphism of applicative structures.
\begin{items}
\item If $x \in \scomp{\struct{A}}{\sigma}$, then we may write $h(x)$ for $h_\sigma(x)$, omitting the type $\sigma$.
\item If $\rho \in \Env[][\struct{A}]$ is an environment for $\struct{A}$, then $\mapenv{h}{\rho} \in \Env[][\struct{B}]$ is the environment defined by $(\mapenv{h}{\rho})(x) = h_\sigma(\rho(x))$ for all $x \in \dom{\rho} \cap \Var[\sigma]$.
\end{items}
\end{notn}

\begin{defn}[Homomorphism of models]
Let $\struct{A}$ and $\struct{B}$ be models. We say that a homomorphism of applicative structures $h : \struct{A} \to \struct{B}$ is a \emph{homomorphism of models} if
\[ h_\sigma(\sint[\struct{A}]{t}{\rho}) = \sint[\struct{B}]{t}{\mapenv{h}{\rho}} \]
for all $\typedtm{t}{\sigma}$ and $\typedenv{\rho}{\FV{t}}$.
\end{defn}

Equivalently, using the combinatory model formulation, a homomorphism of models $h : \struct{A} \to \struct{B}$ can be defined as a homomorphism of applicative structures such that
\[ h(K^\struct{A}_{\sigma,\tau}) = K^\struct{B}_{\sigma,\tau} \quad\text{and}\quad
    h(S^\struct{A}_{\sigma,\tau,\chi}) = S^\struct{B}_{\sigma,\tau,\chi}. \]

%TODO examples?

%TODO what else to say about this category?
For every model $\struct{A}$, there is an identity homomorphism $\id[\struct{A}] : \struct{A} \to \struct{A}$ which is the identity function at every type. Furthermore, homomorphisms $f : \struct{A} \to \struct{B}$ and $g : \struct{B} \to \struct{C}$ can be composed pointwise to yield a homomorphism $gf : \struct{A} \to \struct{C}$. Thus, Henkin models and homomorphisms of models form a category.

\begin{comment}
How useful is this example?
\begin{ex}
Let $X = (X_\beta)_{\beta \in \Basetypes}$ and $Y = (Y_\beta)_{\beta \in \Basetypes}$ be to families of sets indexed by base types, and suppose we have a family of bijections $(p_\beta : X_\beta \to Y_\beta)_{\beta \in \Basetypes}$ between the corresponding sets. This gives rise to a homomorphism $\stdmod{p} : \stdmod{X} \to \stdmod{Y}$ from the standard model over $X$ to the standard model over Y. The maps $\stdmod{p}_\sigma$ are defined by recursion on types:
\begin{align*}
\stdmod{p}_\beta(x) &= p_\beta(x) \\
\stdmod{p}_{\functy{\sigma}{\tau}}(f) &= \stdmod{p}_\tau \circ f \circ (\stdmod{p}_\sigma)^{-1}
\end{align*}
\end{ex}
\end{comment}
